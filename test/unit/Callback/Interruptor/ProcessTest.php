<?php
/**
 * @copyright Copyright Â© 2014 Rollun LC (http://rollun.com/)
 * @license LICENSE.md New BSD License
 */

namespace rollun\test\unit\Callback\Interruptor;

use PHPUnit\Framework\TestCase;
use Psr\Log\LoggerInterface;
use rollun\callback\Callback\CallbackException;
use rollun\callback\Callback\SerializedCallback;
use rollun\callback\Callback\Interrupter\Process;
use rollun\logger\Writer\Stream;

/**
 * Generated by PHPUnit_SkeletonGenerator on 2016-10-13 at 12:52:54.
 */
class ProcessTest extends TestCase
{
    protected const TEST_OUTPUT_TILE = 'data/testOutput.log';

    protected function tearDown(): void
    {
        unlink(self::TEST_OUTPUT_TILE);
    }

    public function testParallelProcess()
    {
        $callback = new SerializedCallback(function ($file) {
            sleep(1);
            $time = microtime(true);
            file_put_contents($file, "$time\n", FILE_APPEND);
        });

        (new Process($callback))(self::TEST_OUTPUT_TILE);
        (new Process($callback))(self::TEST_OUTPUT_TILE);
        sleep(3);
        $timeData = file_get_contents(self::TEST_OUTPUT_TILE);
        list($firstTime, $secondTime) = explode("\n", $timeData);
        if (abs((float) $firstTime - (float) $secondTime) < 0.5) {
            $result = 'parallel';
        } else {
            $result = 'in series';
        }
        if (substr(php_uname(), 0, 7) === "Windows") {
            $this->assertEquals('in series', $result);
        } else {
            $this->assertEquals('parallel', $result);
        }
    }

    public function testUnserializedCallbackProcess()
    {
        global $container;

       $callback = new SerializedCallback(new class {
            public function __invoke(){}
        });

        $logger = $container->get(LoggerInterface::class);
        foreach ($logger->getWriters() as $key => $writer) {
            $writer->shutdown();
        }
        $logger->addWriter(new Stream(self::TEST_OUTPUT_TILE));

        $process = new Process($callback, null, null, $logger);

        $this->expectException(CallbackException::class);

        $process();
    }

    public function testUnserializedCallbackProcessLogging()
    {
        global $container;

        $callback = new SerializedCallback(new class {
            public function __invoke(){}
        });

        $logger = $container->get(LoggerInterface::class);
        foreach ($logger->getWriters() as $key => $writer) {
            $writer->shutdown();
        }
        $logger->addWriter(new Stream(self::TEST_OUTPUT_TILE));

        $process = new Process($callback, null, null, $logger);

        try {
            $process();
        } catch (\Throwable $exception) {

        }

        $log = file_get_contents(self::TEST_OUTPUT_TILE);
        $this->assertNotEmpty($log);
    }
}
